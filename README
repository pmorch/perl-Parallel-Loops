Parallel::Loops(3)    User Contributed Perl Documentation   Parallel::Loops(3)



NNAAMMEE
       Parallel::Loops - Execute loops using parallel forked subprocesses

SSYYNNOOPPSSIISS
           use Parallel::Loops;

           my $maxProcs = 5;
           my $pl = Parallel::Loops->new($maxProcs);

           my @parameters = ( 0 .. 9 );

           # We want to perform some hefty calculation for each @input and
           # store each calculation's result in %output. For that reason, we
           # "tie" %output, so that changes to %output in any child process
           # (see below) are automatically transfered and updated in the
           # parent also.

           my %returnValues;
           $pl->share( \%returnValues );

           $pl->foreach( \@parameters, sub {
               # This sub "magically" executed in parallel forked child
               # processes

               # Lets just create a simple example, but this could be a
               # massive calculation that will be parallelized, so that
               # $maxProcs different processes are calculating sqrt
               # simultaneously for different values of $_ on different CPUs

               $returnValues{$_} = sqrt($_);
           });
           foreach (@parameters) {
               printf "i: %d sqrt(i): %f\n", $_, $returnValues{$_};
           }

       You can also use @arrays instead of %hashes, and/or while loops instead
       of foreach:

           my @returnValues;
           $pl->share(\@returnValues);

           my $i = 0;
           $pl->while ( sub { $i++ < 10 }, sub {
               # This sub "magically" executed in parallel forked
               # child processes

               push @returnValues, [ $i, sqrt($i) ];
           });

       And you can have both foreach and while return values so that
       $pl->_s_h_a_r_e_(_) isn't required at all:

           my $maxProcs = 5;
           my $pl = Parallel::Loops->new($maxProcs);
           my %returnValues = $pl->foreach( [ 0..9 ], sub {
               # Again, this is executed in a forked child
               $_ => sqrt($_);
           });

EExxcceeppttiioonn//EErrrroorr HHaannddlliinngg // DDyyiinngg
       If you want some measure of exception handling you can use eval in the
       child like this:

           my %errors;
           $pl->share( \%errors );
           my %returnValues = $pl->foreach( [ 0..9 ], sub {
               # Again, this is executed in a forked child
               eval {
                   die "Bogus error"
                       if $_ == 3;
                   $_ => sqrt($_);
               };
               if ($@) {
                   $errors{$_} = $@;
               }
           });

           # Now test %errors. $errors{3} should exist as teh only element

       Also, be sure not to call _e_x_i_t_(_) in the child. That will just exit the
       child and that doesn't work. Right now, exit just makes the parent fail
       no-so-nicely.  Patches to this that handle exit somehow are welcome.

DDEESSCCRRIIPPTTIIOONN
       Often a loop performs calculations where each iteration of the loop
       does not depend on the previous iteration, and the iterations really
       could be carried out in any order.

       This module allows you to run such loops in parallel using all the CPUs
       at your disposal.

       Return values are automatically transfered from children to parents via
       %hashes or @arrays, that have explicitly been configured for that sort
       of sharing via $pl->_s_h_a_r_e_(_). Hashes will transfer keys that are set in
       children (but not cleared or unset), and elements that are pushed to
       @arrays in children are pushed to the parent @array too (but note that
       the order is not guaranteed to be the same as it would have been if
       done all in one process, since there is no way of knowing which child
       would finish first!)

       If you can see past the slightly awkward syntax, you're basically
       getting foreach and while loops that can run in parallel without having
       to bother with fork, pipes, signals etc. This is all handled for you by
       this module.

   ffoorreeaacchh lloooopp
           $pl->foreach($arrayRef, $childBodySub)

       Runs $childBodySub->() with $_ set foreach element in @$arrayRef,
       except that $childBodySub is run in a forked child process to obtain
       parallelism.  Essentially, this does something conceptually similar to:

           foreach(@$arrayRef) {
               $childBodySub->();
           }

       Any setting of hash keys or pushing to arrays that have been set with
       $pl->_s_h_a_r_e_(_) will automagically appear in the hash or array in the
       parent process.

       If you like loop variables, you can run it like so:

           $pl->foreach( \@input, sub {
                   my $i = $_;
                   .. bla, bla, bla ... $output{$i} = sqrt($i);
               }
           );

   wwhhiillee lloooopp
         $pl->while($conditionSub, $childBodySub)

       Essentially, this does something conceptually similar to:

         while($conditionSub->()) {
             $childBodySub->();
         }

       except that $childBodySub->() is executed in a forked child process.
       Return values are transfered via _s_h_a_r_e_(_) like in "foreach loop" above.

       _w_h_i_l_e _l_o_o_p_s _m_u_s_t _a_f_f_e_c_t _c_o_n_d_i_t_i_o_n _o_u_t_s_i_d_e _$_c_h_i_l_d_B_o_d_y_S_u_b

       Note that incrementing $i in the $childBodySub like in this example
       wwiillll nnoott wwoorrkk:

          $pl->while( sub { $i < 5 },
                      sub {
                          $output{$i} = sqrt($i);
                          # Won't work!
                          $i++
                      }
                    );

       Because $childBodySub is executed in a child, and so while $i would be
       incremented in the child, that change would not make it to the parent,
       where $conditionSub is evaluated. The changes that make $conditionSub
       return false eventually _m_u_s_t take place outside the $childBodySub so it
       is executed in the parent. (Adhering to the parallel principle that one
       iteration may not affect any other iterations - including whether to
       run them or not)

   sshhaarree
         $pl->share(\%output, \@output, ...)

       Each of the arguments to _s_h_a_r_e_(_) are instrumented, so that when a hash
       key is set or array element pushed in a child, this is transfered to
       the parent's hash or array automatically when a child is finished.

       NNoottee tthhee lliimmiittaattiioonn Only keys being set like "$hash{'key'} = 'value'"
       and arrays elements being pushed like "push @array, 'value'" will be
       transfered to the parent. Unsetting keys, or setting particluar array
       elements with $array[3]='value' will be lost if done in the children.
       Also, if two different children set a value for the same key, a random
       one of them will be seen by the parent.

       In the parent process all the %hashes and @arrays are full-fledged, and
       you can use all operations.  But only these mentioned operations in the
       child processes make it back to the parent.

       _A_r_r_a_y _e_l_e_m_e_n_t _s_e_q_u_e_n_c_e _n_o_t _d_e_f_i_n_e_d

       Note that when using _s_h_a_r_e_(_) for @returnValue arrays, the sequence of
       elements in @returnValue is not guaranteed to be the same as you'd see
       with a normal sequential while or foreach loop, since the calculations
       are done in parallel and the children may end in an unexpected
       sequence.  But if you don't really care about the order of elements in
       the @returnValue array then share-ing an array can be useful and fine.

       If you need to be able to determine which iteration generated what
       output, use a hash instead.

   RReeccuurrssiivvee ffoorrkkiinngg iiss ppoossssiibbllee
       Note that no check is performed for recursive forking: If the main
       process encouters a loop that it executes in parallel, and the
       execution of the loop in child processes also encounters a parallel
       loop, these will also be forked, and you'll essentially have
       $maxProcs^2 running processes. It wouldn't be too hard to implement
       such a check (either inside or outside this package).

SSEEEE AALLSSOO
       This module uses _f_o_r_k_(_). ithreads could have been possible too, but was
       not chosen. You may want to check out:

       When to use forks, when to use threads ...?
       <http://www.perlmonks.org/index.pl?node_id=709061>

       The forks module (not used here)
       <http://search.cpan.org/search?query=forks>

       threads in perlthrtut <http://perldoc.perl.org/perlthrtut.html>

DDEEPPEENNDDEENNCCIIEESS
       I believe this is the only dependency that isn't part of core perl:

           use Parallel::ForkManager;

       These should all be in perl's core:

           use Storable;
           use IO::Handle;
           use Tie::Array;
           use Tie::Hash;
           use UNIVERSAL qw(isa);

BBUUGGSS // EENNHHAANNCCEEMMEENNTTSS
       No bugs are known at the moment. Send any reports to peter@morch.com.

       Enhancements:

       Optionally prevent recursive forking: If a forked child encounters a
       Parallel::Loop it should be possible to prevent that Parallel::Loop
       instance to also create forks.

       Determine the number of CPUs so that _n_e_w_(_)'s $maxProcs parameter can be
       optional. Could use e.g. Sys::Sysconf, UNIX::Processors or Sys::CPU.

       Maybe use function prototypes (see Prototypes under perldoc perlsub).

       Then we could do something like

           pl_foreach @input {
               yada($_);
           };
       or

           pl_foreach $pl @input {
               yada($_);
           };

       instead of

           $pl->foreach(\@input, sub {
               yada($_);
           });

       and so on, where the first suggestion above means global variables
       (yikes!).  Unfortunately, methods aren't supported by prototypes, so
       this will never be posssible:

           $pl->foreach @input {
               yada($_);
           };

       An alternative pointed out by the perlmonks chatterbox could be to use
       <Devel::Declare> "if I can stand pain".

CCOOPPYYRRIIGGHHTT
       Copyright (c) 2008 Peter Valdemar Morch <peter@morch.com>

       All right reserved. This program is free software; you can redistribute
       it and/or modify it under the same terms as Perl itself.

AAUUTTHHOORR
         Peter Valdemar Morch <peter@morch.com>



perl v5.10.1                      2011-02-09                Parallel::Loops(3)
